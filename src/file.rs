use std::borrow::Cow;
use std::io::{BufReader, BufWriter, Read, Write};
use std::mem::size_of;

use anyhow::{Context, Error, anyhow};
use pcap_file::{
    pcap::{PcapReader, PcapHeader, PcapWriter, RawPcapPacket},
    DataLink,
    TsResolution,
};

/// Item type generated by file loaders.
pub enum LoaderItem<PacketData> {
    Packet(PacketData),
    LoadError(Error),
    Ignore,
    End
}

/// Interface to packets from capture loaders.
pub trait GenericPacket {
    /// The bytes of the raw packet.
    fn bytes(&self) -> &[u8];

    /// Timestamp in nanoseconds since start of capture.
    fn timestamp_ns(&self) -> u64;

    /// Total bytes read from the input including this packet.
    fn total_bytes_read(&self) -> u64;
}

/// Interface to capture loaders.
pub trait GenericLoader<Source>
where Self: Sized, Source: Read
{
    type PacketData<'p>;

    /// Create a loader for a byte source.
    fn new(source: Source) -> Result<Self, Error>;

    /// Get the next item.
    fn next(&mut self) -> LoaderItem<impl GenericPacket>;
}

/// Interface to capture savers.
pub trait GenericSaver<Dest>
where Self: Sized, Dest: Write
{
    /// Create a saver for a byte sink.
    fn new(dest: Dest) -> Result<Self, Error>;

    /// Add the next packet.
    fn add_packet(&mut self, bytes: &[u8], timestamp_ns: u64) -> Result<(), Error>;

    /// Finish saving after the last packet is added.
    fn close(self) -> Result<(), Error>;
}

/// Loader for pcap format.
pub struct PcapLoader<Source: Read> {
    pcap: PcapReader<BufReader<Source>>,
    bytes_read: u64,
    frac_ns: u64,
    start_time: Option<u64>,
}

/// Saver for pcap format.
pub struct PcapSaver<Dest: Write> {
    pcap: PcapWriter<BufWriter<Dest>>,
}

/// Helper type for wrapping existing packets.
pub struct PacketWrapper<PacketData> {
    packet_data: PacketData,
    timestamp_ns: u64,
    total_bytes_read: u64,
}

impl<Source> GenericLoader<Source>
for PcapLoader<Source>
where Source: Read
{
    type PacketData<'p> = PacketWrapper<RawPcapPacket<'p>>;

    fn new(source: Source) -> Result<Self, Error> {
        let reader = BufReader::new(source);
        let pcap = PcapReader::new(reader)?;
        let header = pcap.header();
        let bytes_read = size_of::<PcapHeader>() as u64;
        let frac_ns = match header.ts_resolution {
            TsResolution::MicroSecond => 1_000,
            TsResolution::NanoSecond => 1,
        };
        let start_time = None;
        Ok(PcapLoader{pcap, bytes_read, frac_ns, start_time})
    }

    fn next(&mut self) -> LoaderItem<impl GenericPacket> {
        use LoaderItem::*;
        match self.pcap.next_raw_packet() {
            None => End,
            Some(Err(e)) => LoadError(anyhow!(e)),
            Some(Ok(raw_packet)) => {
                let raw_timestamp =
                    raw_packet.ts_sec as u64 * 1_000_000_000 +
                    raw_packet.ts_frac as u64 * self.frac_ns;
                let timestamp = if let Some(start) = self.start_time {
                    raw_timestamp - start
                } else {
                    self.start_time = Some(raw_timestamp);
                    0
                };
                let size = 16 + raw_packet.data.len();
                self.bytes_read += size as u64;
                Packet(
                    PacketWrapper {
                        packet_data: raw_packet,
                        timestamp_ns: timestamp,
                        total_bytes_read: self.bytes_read
                    }
                )
            }
        }
    }
}

impl<Dest> GenericSaver<Dest>
for PcapSaver<Dest>
where Self: Sized, Dest: Write
{
    fn new(dest: Dest) -> Result<Self, Error> {
        let writer = BufWriter::new(dest);
        let header = PcapHeader {
            datalink: DataLink::USB_2_0,
            ts_resolution: TsResolution::NanoSecond,
            .. PcapHeader::default()
        };
        Ok(PcapSaver { pcap: PcapWriter::with_header(writer, header)? })
    }

    fn add_packet(&mut self, bytes: &[u8], timestamp_ns: u64)
        -> Result<(), Error>
    {
        let length: u32 = bytes
            .len()
            .try_into()
            .context("Packet too large for pcap file")?;
        let packet = RawPcapPacket {
            ts_sec: (timestamp_ns / 1_000_000_000) as u32,
            ts_frac: (timestamp_ns % 1_000_000_000) as u32,
            incl_len: length,
            orig_len: length,
            data: Cow::from(bytes)
        };
        self.pcap.write_raw_packet(&packet)?;
        Ok(())
    }

    fn close(self) -> Result<(), Error> {
        self.pcap.into_writer().flush()?;
        Ok(())
    }
}

impl GenericPacket for PacketWrapper<RawPcapPacket<'_>> {
    fn bytes(&self) -> &[u8] { &self.packet_data.data }
    fn timestamp_ns(&self) -> u64 { self.timestamp_ns }
    fn total_bytes_read(&self) -> u64 { self.total_bytes_read }
}
