use std::borrow::Cow;
use std::io::{BufReader, BufWriter, Read, Write};
use std::mem::size_of;
use std::num::NonZeroU32;
use std::sync::Arc;
use std::time::Duration;

use anyhow::{Context, Error, anyhow};
use pcap_file::{
    pcap::{PcapReader, PcapHeader, PcapWriter, RawPcapPacket},
    pcapng::{
        PcapNgReader, PcapNgWriter,
        blocks::{
            Block,
            section_header:: {
                SectionHeaderBlock,
                SectionHeaderOption,
            },
            interface_description::{
                InterfaceDescriptionBlock,
                InterfaceDescriptionOption,
            },
            interface_statistics::{
                InterfaceStatisticsBlock,
                InterfaceStatisticsOption,
            },
            enhanced_packet::EnhancedPacketBlock,
        },
    },
    DataLink,
    TsResolution,
};

use crate::capture::CaptureMetadata;
use crate::usb::Speed;
use crate::version::version;

/// Item type generated by file loaders.
pub enum LoaderItem<PacketData> {
    Packet(PacketData),
    Metadata(Box<CaptureMetadata>),
    LoadError(Error),
    Ignore,
    End
}

/// Interface to packets from capture loaders.
pub trait GenericPacket {
    /// The bytes of the raw packet.
    fn bytes(&self) -> &[u8];

    /// Timestamp in nanoseconds since start of capture.
    fn timestamp_ns(&self) -> u64;

    /// Total bytes read from the input including this packet.
    fn total_bytes_read(&self) -> u64;
}

/// Interface to capture loaders.
pub trait GenericLoader<Source>
where Self: Sized, Source: Read
{
    type PacketData<'p>;

    /// Create a loader for a byte source.
    fn new(source: Source) -> Result<Self, Error>;

    /// Get the next item.
    fn next(&mut self) -> LoaderItem<impl GenericPacket>;
}

/// Interface to capture savers.
pub trait GenericSaver<Dest>
where Self: Sized, Dest: Write
{
    /// Create a saver for a byte sink.
    fn new(dest: Dest, meta: Arc<CaptureMetadata>) -> Result<Self, Error>;

    /// Add the next packet.
    fn add_packet(&mut self, bytes: &[u8], timestamp_ns: u64) -> Result<(), Error>;

    /// Finish saving after the last packet is added.
    fn close(self) -> Result<(), Error>;
}

/// Loader for pcap format.
pub struct PcapLoader<Source: Read> {
    pcap: PcapReader<BufReader<Source>>,
    bytes_read: u64,
    frac_ns: u64,
    start_time: Option<u64>,
}

/// Saver for pcap format.
pub struct PcapSaver<Dest: Write> {
    pcap: PcapWriter<BufWriter<Dest>>,
}

/// Helper type for wrapping existing packets.
pub struct PacketWrapper<PacketData> {
    packet_data: PacketData,
    timestamp_ns: u64,
    total_bytes_read: u64,
}

impl<Source> GenericLoader<Source>
for PcapLoader<Source>
where Source: Read
{
    type PacketData<'p> = PacketWrapper<RawPcapPacket<'p>>;

    fn new(source: Source) -> Result<Self, Error> {
        let reader = BufReader::new(source);
        let pcap = PcapReader::new(reader)?;
        let header = pcap.header();
        let bytes_read = size_of::<PcapHeader>() as u64;
        let frac_ns = match header.ts_resolution {
            TsResolution::MicroSecond => 1_000,
            TsResolution::NanoSecond => 1,
        };
        let start_time = None;
        Ok(PcapLoader{pcap, bytes_read, frac_ns, start_time})
    }

    fn next(&mut self) -> LoaderItem<impl GenericPacket> {
        use LoaderItem::*;
        match self.pcap.next_raw_packet() {
            None => End,
            Some(Err(e)) => LoadError(anyhow!(e)),
            Some(Ok(raw_packet)) => {
                let raw_timestamp =
                    raw_packet.ts_sec as u64 * 1_000_000_000 +
                    raw_packet.ts_frac as u64 * self.frac_ns;
                let timestamp = if let Some(start) = self.start_time {
                    raw_timestamp - start
                } else {
                    self.start_time = Some(raw_timestamp);
                    0
                };
                let size = 16 + raw_packet.data.len();
                self.bytes_read += size as u64;
                Packet(
                    PacketWrapper {
                        packet_data: raw_packet,
                        timestamp_ns: timestamp,
                        total_bytes_read: self.bytes_read
                    }
                )
            }
        }
    }
}

impl<Dest> GenericSaver<Dest>
for PcapSaver<Dest>
where Self: Sized, Dest: Write
{
    fn new(dest: Dest, _meta: Arc<CaptureMetadata>) -> Result<Self, Error> {
        let writer = BufWriter::new(dest);
        let header = PcapHeader {
            datalink: DataLink::USB_2_0,
            ts_resolution: TsResolution::NanoSecond,
            .. PcapHeader::default()
        };
        Ok(PcapSaver { pcap: PcapWriter::with_header(writer, header)? })
    }

    fn add_packet(&mut self, bytes: &[u8], timestamp_ns: u64)
        -> Result<(), Error>
    {
        let length: u32 = bytes
            .len()
            .try_into()
            .context("Packet too large for pcap file")?;
        let packet = RawPcapPacket {
            ts_sec: (timestamp_ns / 1_000_000_000) as u32,
            ts_frac: (timestamp_ns % 1_000_000_000) as u32,
            incl_len: length,
            orig_len: length,
            data: Cow::from(bytes)
        };
        self.pcap.write_raw_packet(&packet)?;
        Ok(())
    }

    fn close(self) -> Result<(), Error> {
        self.pcap.into_writer().flush()?;
        Ok(())
    }
}

impl GenericPacket for PacketWrapper<RawPcapPacket<'_>> {
    fn bytes(&self) -> &[u8] { &self.packet_data.data }
    fn timestamp_ns(&self) -> u64 { self.timestamp_ns }
    fn total_bytes_read(&self) -> u64 { self.total_bytes_read }
}

/// Loader for pcap-ng format.
pub struct PcapNgLoader<Source: Read> {
    pcap: PcapNgReader<BufReader<Source>>,
    initial_metadata: Option<CaptureMetadata>,
    interface_seen: bool,
    ts_start: Option<Duration>,
}

/// Saver for pcap-ng format.
pub struct PcapNgSaver<'s, Dest: Write> {
    pcap: PcapNgWriter<'s, BufWriter<Dest>>,
    meta: Arc<CaptureMetadata>,
}

impl<Source> GenericLoader<Source>
for PcapNgLoader<Source>
where Source: Read
{
    type PacketData<'p> = PacketWrapper<EnhancedPacketBlock<'p>>;

    fn new(source: Source) -> Result<Self, Error> {
        let reader = BufReader::new(source);
        let pcap = PcapNgReader::new(reader)?;
        let section_header = pcap.section();
        let initial_metadata = Some({
            let mut meta = CaptureMetadata::default();
            for option in &section_header.options {
                use SectionHeaderOption::*;
                match option {
                    UserApplication(application) => {
                        meta.application.replace(application.to_string());
                    },
                    OS(os) => {
                        meta.os.replace(os.to_string());
                    },
                    Hardware(hardware) => {
                        meta.hardware.replace(hardware.to_string());
                    },
                    Comment(comment) => {
                        meta.comment.replace(comment.to_string());
                    },
                    _ => {}
                };
            }
            meta
        });
        Ok(PcapNgLoader{
            pcap,
            initial_metadata,
            interface_seen: false,
            ts_start: None
        })
    }

    fn next(&mut self) -> LoaderItem<impl GenericPacket> {
        use DataLink::*;
        use LoaderItem::*;
        if let Some(meta) = self.initial_metadata.take() {
            return Metadata(Box::new(meta))
        }
        let total_bytes_read = self.pcap.bytes_parsed();
        let block = match self.pcap.next_block() {
            None => return End,
            Some(Err(e)) => return LoadError(anyhow!(e)),
            Some(Ok(block)) => block
        };
        match block {
            Block::EnhancedPacket(epb) => {
                let timestamp_ns: u128 = if let Some(ts_start) = self.ts_start {
                    (epb.timestamp - ts_start).as_nanos()
                } else {
                    self.ts_start = Some(epb.timestamp);
                    0
                };
                let timestamp_ns: u64 = match timestamp_ns.try_into() {
                    Ok(ns) => ns,
                    Err(e) => return LoadError(anyhow!(e))
                };
                Packet(
                    PacketWrapper {
                        packet_data: epb,
                        timestamp_ns,
                        total_bytes_read,
                    }
                )
            },
            Block::SectionHeader(_) =>
                LoadError(anyhow!(
                    "Multiple sections are not supported.")),
            Block::InterfaceDescription(interface) => {
                use InterfaceDescriptionOption::*;
                use Speed::*;
                if self.interface_seen {
                    return LoadError(anyhow!(
                        "Multiple interfaces are not supported"))
                } else {
                    self.interface_seen = true;
                }
                let mut meta = CaptureMetadata::default();
                match interface.linktype {
                    USB_2_0 => {},
                    USB_2_0_HIGH_SPEED => {
                        meta.iface_speed.replace(High);
                    },
                    USB_2_0_FULL_SPEED => {
                        meta.iface_speed.replace(Full);
                    },
                    USB_2_0_LOW_SPEED => {
                        meta.iface_speed.replace(Low);
                    },
                    _ => return LoadError(anyhow!(
                        "Link type {:?} is not supported.",
                        interface.linktype)),
                };
                meta.iface_snaplen = NonZeroU32::new(interface.snaplen);
                for option in interface.options {
                    match option {
                        IfDescription(desc) => {
                            meta.iface_desc.replace(desc.to_string());
                        },
                        IfHardware(hw) => {
                            meta.iface_hardware.replace(hw.to_string());
                        },
                        IfOs(os) => {
                            meta.iface_os.replace(os.to_string());
                        },
                        _ => {}
                    };
                }
                Metadata(Box::new(meta))
            },
            Block::InterfaceStatistics(stats) => {
                use InterfaceStatisticsOption::*;
                let mut meta = CaptureMetadata::default();
                for option in stats.options {
                    match option {
                        IsbStartTime(time) => { meta.start_time.replace(time); },
                        IsbEndTime(time) => { meta.end_time.replace(time); },
                        IsbIfDrop(pkts) => { meta.dropped.replace(pkts); },
                        _ => {}
                    };
                }
                Metadata(Box::new(meta))
            },
            _ => Ignore
        }
    }
}

fn string(string: &str) -> Option<Cow<'_, str>> {
    Some(Cow::from(string))
}

fn speed_bps(speed: &Speed) -> Option<u64> {
    use Speed::*;
    match speed {
        Low  => Some(  1_500_000),
        Full => Some( 12_000_000),
        High => Some(480_000_000),
        Auto => None,
    }
}

fn duration(duration: &Duration) -> Option<Duration> {
    Some(*duration)
}

macro_rules! option {
    ($src: ident,
     $dest: ident,
     $name: ident,
     $variant: ident,
     $converter: expr) => {
        if let Some($name) = &$src.$name {
            if let Some(value) = $converter($name) {
                $dest.push($variant(value))
            }
        }
    }
}

fn iface_options(meta: &CaptureMetadata)
    -> Vec<InterfaceDescriptionOption>
{
    use InterfaceDescriptionOption::*;
    // Always store nanosecond resolution.
    let mut opt = vec![IfTsResol(9)];
    option!(meta, opt, iface_desc, IfDescription, string);
    option!(meta, opt, iface_hardware, IfHardware, string);
    option!(meta, opt, iface_os, IfOs, string);
    option!(meta, opt, iface_speed, IfSpeed, speed_bps);
    opt
}

fn stats_options(meta: &CaptureMetadata)
    -> Vec<InterfaceStatisticsOption>
{
    use InterfaceStatisticsOption::*;
    let mut opt = Vec::new();
    option!(meta, opt, start_time, IsbStartTime, duration);
    option!(meta, opt, end_time, IsbEndTime, duration);
    if let Some(pkts) = meta.dropped {
        opt.push(IsbIfDrop(pkts));
    }
    opt
}

impl<Dest> GenericSaver<Dest>
for PcapNgSaver<'_, Dest>
where Self: Sized, Dest: Write
{
    fn new(dest: Dest, meta: Arc<CaptureMetadata>) -> Result<Self, Error> {
        let writer = BufWriter::new(dest);
        let mut section = SectionHeaderBlock {
            options: vec![
                SectionHeaderOption::UserApplication(
                    Cow::from(format!("Packetry {}", version()))
                ),
                SectionHeaderOption::OS(
                    Cow::from(std::env::consts::OS)
                ),
                SectionHeaderOption::Hardware(
                    Cow::from(std::env::consts::ARCH)
                ),
            ],
            .. Default::default()
        };
        if let Some(comment) = &meta.comment {
            section.options.push(
                SectionHeaderOption::Comment(
                    Cow::from(comment.clone())
                )
            );
        }
        let mut pcap = PcapNgWriter::with_section_header(writer, section)?;
        pcap.write_block(&Block::InterfaceDescription(
            InterfaceDescriptionBlock {
                linktype: DataLink::USB_2_0,
                snaplen: meta.iface_snaplen.map_or(0, NonZeroU32::get),
                options: iface_options(&meta),
            }
        ))?;
        Ok(PcapNgSaver { pcap, meta })
    }

    fn add_packet(&mut self, bytes: &[u8], timestamp_ns: u64)
        -> Result<(), Error>
    {
        let length: u32 = bytes
            .len()
            .try_into()
            .context("Packet too large for pcap file")?;
        let timestamp = Duration::from_nanos(timestamp_ns);
        self.pcap.write_block(&Block::EnhancedPacket(
            EnhancedPacketBlock {
                interface_id: 0,
                timestamp,
                original_len: length,
                data: Cow::from(bytes),
                options: vec![],
            }
        ))?;
        Ok(())
    }

    fn close(mut self) -> Result<(), Error> {
        self.pcap.write_block(&Block::InterfaceStatistics(
            InterfaceStatisticsBlock {
                interface_id: 0,
                timestamp: match self.meta.end_time {
                    Some(end) => end,
                    None => Duration::from_nanos(0),
                },
                options: stats_options(&self.meta)
            }
        ))?;
        self.pcap.into_inner().flush()?;
        Ok(())
    }
}

impl GenericPacket for PacketWrapper<EnhancedPacketBlock<'_>> {
    fn bytes(&self) -> &[u8] { &self.packet_data.data }
    fn timestamp_ns(&self) -> u64 { self.timestamp_ns }
    fn total_bytes_read(&self) -> u64 { self.total_bytes_read }
}
